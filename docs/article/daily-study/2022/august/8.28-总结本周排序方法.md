# 8.28-总结本周排序方法

## 本周所学
本周学了5种排序算法, 分别是`冒泡排序`,`选择排序`,`快速排序`,`归并排序`,`插入排序`下面对各种算法进行总结

`特别提醒: 主要实现降序`

## 冒泡排序

冒泡排序的时间复杂度为O(n^2)

**算法的原理**

- 比较相邻的元素。如果第一个比第二个大，就交换他们两个
- 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。`在这一点，最后的元素应该会是最大的数`(可优化的地方)
- 针对所有的元素重复以上的步骤，除了最后一个
- 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较

[冒泡排序](https://codevity.top/article/every-insist/august/8.22-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.html)


## 选择排序

选择排序的时间复杂度为O(n^2)

**算法的原理**

- 首先在未排序序列中找到最小元素，存放到排序序列的起始位置。
- 再从剩余未排序元素中继续寻找最小元素，然后放到已排序序列的末尾。
- 重复第二步，直到所有元素均排序完毕。

[选择排序](https://codevity.top/article/every-insist/august/8.23-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.html)

## 快速排序

快速排序时间复杂度在`nlogn~ n^2 之间`

快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序

**算法的原理**

- 先从给定的数组中取出一个基准数(`基准`)
- 划分过程，小于等于基准数的放在左边，大于基准数的放在右边(`分区`)
- 再对左右区间重复第2步操作，直到各区间只有一个数(`递归分区过程`)

## 归并排序

快速排序时间复杂度在` nlog(n)`

**算法的原理**

- 第一步：申请空间，使其大小为两个已经[排序](https://baike.baidu.com/item/排序)序列之和，该空间用来存放合并后的序列

- 第二步：设定两个[指针](https://baike.baidu.com/item/指针)，最初位置分别为两个已经排序序列的起始位置

- 第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置

- 重复步骤3直到某一指针超出序列尾

- 将另一序列剩下的所有元素直接复制到合并序列尾

  

归并排序的整体步骤比较难理解, `需要配合代码和动图来理解`

[归并排序](https://codevity.top/article/every-insist/august/8.25-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.html#%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86)

## 插入排序

插入排序时间复杂度在`n^2`

**算法的原理**

- 从第一个元素开始，该元素可以认为已经被排序
- 取出下一个元素，在已经排序的元素序列中从后向前扫描
- 该元素（已排序的元素）大于当前元素，则将该元素移动到下一个位置
- 重复上一个步骤，直到找到已排序的元素小于或者等于当前元素的位置，将当前元素插入到该位置后，重复上面的步骤

### 特别提醒

- 插入排序适合少量元素的排序的情况
- 相关: sort的原理在元素个数`少于10个的时候,使用的就是插入排序`, `大于10的时候, 使用的是插入 + 快速排序`

## 二分查找

在有序数组中, 我们可以使用`二分查找`来确定某个元素的位置

- 在`二分查找`获取中间索引的时候, `(left + right) / 2`可能会溢出，` left + (right - left) /2`就不会溢出
- 特别注意: 使用二分查找的`前提`必须是一个`有序数组`