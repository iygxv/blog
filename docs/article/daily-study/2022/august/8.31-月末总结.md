# 8.31-总结本月所学

## 第一周

第一周的第一天我们写了`寄生组合继承`, 寄生组合继承是实现`es6 class`的核心,另外我们使用寄生组合继承解决了组合继承的问题

组合继承的一个问题(`调用了2 次父类构造函数`)

- 第一次是在 new Student()中
- 第二次是在 Person.call() 中

第二天我们手写了`Promise中的resolve方法`, 可以知道`resolve`返回的必然是个promise,因此可以接.then等方法

```js
Promise.resolve(1).then(res => {
  console.log(res) // 1
})
```

第三天我们手写了`Promise中的all方法`, 得知了`判断可迭代对象的方法`

```js
typeof promises[Symbol.iterator] === 'function' // 是可迭代对象
```

all方法会`等待所有都完成（或第一个失败）`, 才返回结果

第四天我们手写了`Promise中的allSettled方法`, 可以知道`Promise.allSettled`的实现跟`Promise.all`差不多,当有多个彼此不依赖的异步任务成功完成时，或者总是想知道每个`promise`的结果时，通常使用它

第五天我们手写了`Promise中的any方法`,可以知道`Promise.any`在本质上，这个方法和`Promise.all()`是相反的, 只要其中的一个 promise 成功，就返回那个已经成功的 promise, 或者等待全部失败, 返回一个失败的 promise 和AggregateError类型的实例

第六天我们手写了`Promise中的race方法`,可以知道, `Promise.race`,  无论成功还是失败, 返回最快的一个

第七天我们总结本周PromiseAPI的区别, 知道了Promise中各个API的区别

## 第二周

第二周我们实现了部分数组API的方法, 分别有`reduce`、`flat`、`map`、`includes`、`at`

第一天, 通过`reduce`我们理解了`reduce`整体运行的一个过程

第二天, 通过`flat`我们学了`递归`去实现一个带`深度depth`的flat方法

第三天, 我们实现了`map`, 可以知道map返回的是一个新数组,并不会改变原数组

```js
[1, 2, 11].map(parseInt) // [1, NaN, 3]
```

为什么呢?

因为parseInt(string, radix_), 第一个参数是`要被解析的值`, 第二个参数是`进制数`

[MDN对parseInt的描述](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt)

那么上述的代码就会变成

```js
function parseInt(string, radix_) {}
[1, 2, 11].map(parseInt)
// 变化
[1, 2, 11].map(function parseInt(string, radix_) {
  return parseInt(string, radix_)
})  // [1, NaN, 3]
```

第四天, 我们实现了`includes`,知道了`Object.is`可以判断NaN不想等的情况, NaN是一个非数字,具有`自反性(NaN !== NaN  => true )并且(typeof NaN === 'number')`

第五天, 我们实现了`at`, 知道了获取数组最后一位可以使用at方法, 不用在使用`arr[arr.length - 1]` 来获取了

```js
const arr = [1, 2, 3]
arr.at(-1) // 3
```

第七天, 我们总结了本周数组API

## 第三周

第三周我们实现了在工作上或者面试时, 比较常见的手写题

第一天, 我们手写了`交换a,b的值, 不使用临时变量`, 我们巧妙的利用了加减法去实现了在不使用临时变量的情况下进行了交换

```js
let a = 1
let b = 2

a = a + b // 1 + 2 = 3
b = a - b // 3 - 2 = 1
a = a - b // 3 - 1 = 2

// 进行交换后
a // 2
b // 1
```

另外, 我们在交换数组的元素的时候, 可以使用`解构`的方法去实现

```js
const arr = [1, 2, 3];
[arr[2], arr[0]] = [arr[0], arr[2]]
arr // [3, 2, 1]
```

第二天, 我们手写了`数组的乱序输出`, 我们也是利用了第一天的数组元素(`解构`)的去实现了交换,  在这一天, 我们学到了

```js
const arr = [1, 2, 3, 5, 6, 7];
arr.sort(() => Math.random() - 0.5) // 乱序
```

使用`arr.sort`也可以实现乱序, 但是这种方法的乱序还不够乱, 因此由我们自身去实现这种乱序方法(`我们也叫做洗牌算法`)

并且, 在这一天, 我们知道了`v8 在实现 sort 方法时，当目标数组长度小于 10 时，使用插入排序；反之，使用快速排序和插入排序的混合排序`

第三天, 我们手写了`实现对象扁平化`, 对象扁平化并不像数组扁平化这么容易, 实现对象扁平化同样需要递归, 在递归中, 我们需要知道,`递归的出口, 以及哪里需要递归`

这是递归一个非常重要的一个点

第四天, 第五天, 我们实现了`JSON.stringify`, 通过理解他的九大特性,我们可以逐步的去实现它, 这是对自身基础的一个挑战, 需要把很多知识结合起来

第七天, 我们总结了本周的一个实现

## 第四周

第四周, 我们的着重点是`排序算法`

第一天, 我们实现了`冒泡排序`, 冒泡排序的时间复杂度为O(n^2), 并且是一种`稳定`的排序算法

第二天, 我们实现了`选择排序`, 选择排序的时间复杂度为O(n^2), 并且是一种`不稳定`的排序算法

第三天, 我们实现了`快速排序`, 快速排序的时间复杂度在`nlogn~ n^2 之间`, 快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。

第四天, 我们实现了`归并排序`, 归并排序时间复杂度在` nlog(n)`, `归并排序`的总体理解难度较难, 具体的代码需要自己用例子的数据去理解(并加以动图去理解)

第五天, 我们实现了`插入排序`, 插入排序时间复杂度在`n^2`, `插入排序`适合少量元素的排序的情况

第六天, 我们使用了`二分查找`来确定一个数在一个`有序数组`中的位置, 我们明白了使用二分查找的前提必须是一个`有序数组`

第七天, 我们总结了本周的`排序算法`

## 月最后3天

在8月的最后3天, 第一天我们去理解了`事件循环`, 我们知道`js是单线程`,因为js作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定js同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？所以，为了避免复杂性，因此`js是单线程`。

因为`js是单线程`, 所以js引入了`同步任务`和`异步任务`,异步任务还有更精确的区分

- 微任务
- 宏任务

**浏览器事件循环的一个大概**

- js是单线程语言，分为同步任务和异步任务, 同步任务同步执行，异步任务异步执行
- 在执行代码的过程中, 先去执行同步任务,等待同步任务完成后,然后会去执行异步任务
- 异步任务又分为宏微任务, 遇到宏任务,放入到宏任务队列里,遇到微任务,放入到微任务队列里
- 等待同步任务完成, 然后开始执行宏微任务,(`微任务优先于宏任务`),本次队列清空, 然后继续寻找宏任务,
- 以此反复直到清空所有宏任务，这种不断重复的执行机制，就叫做`事件循环`

第二天, 我们训练了大量的`Promise训练题`来去理解事件循环,来理解宏微任务

第三天, 我们总结了本月所学的知识, 看到这里, 继续为自己加油, 相信付出会有收获的, 可能短暂会看不到,但是未来你会发现那份属于你的知识已经存在于你心中

## 下个月

下一个月可能会偏向于http知识去学习 

