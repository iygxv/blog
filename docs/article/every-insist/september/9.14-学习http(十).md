# 9.14-学习http(十)

## **HTTP的Cookie机制** 

### **描述**

之前有了解过, HTTP 是无状态的，这既是优点也是缺点。优点是服务器没有状态差异，可以很容易地组成集群，而缺点就是无法支持需要记录状态的事务操作。

好在 HTTP 协议是可扩展的，后来发明的 Cookie 技术，给 HTTP 增加了记忆能力。(`Cookie是为了给http增加记忆能力`)

### **什么是Cookie?**

`Cookie是服务器在客户端上贴上只有服务器才能理解的数据`,只要客户端把这些信息发给服务器，服务器看到 Cookie，就能够认出对方是谁了

### **Cookie的工作过程**

通过两个字段: 响应头字段**Set-Cookie**和请求头字段**Cookie**

当用户通过浏览器第一次访问服务器的时候，服务器肯定是不知道他的身份的。所以，就要创建一个独特的身份标识数据，格式是**key=value**，然后放进 Set-Cookie 字段里， 随着响应报文一同发给浏览器。

浏览器收到响应报文，看到里面有 Set-Cookie，知道这是服务器给的身份标识，于是就保存起来，下次再请求的时候就自动把这个值放进 Cookie 字段里发给服务器。

因为第二次请求里面有了 Cookie 字段，服务器就知道这个用户不是新人，之前来过，就可以拿出 Cookie 里的值，识别出用户的身份，然后提供个性化的服务。

不过因为服务器的记忆能力实在是太差，一张小纸条经常不够用。所以，服务器有时会在响应头里添加多个 Set-Cookie，存储多个key=value。但浏览器这边发送时不需要 用多个 Cookie 字段，只要在一行里用`;`隔开就行。

如果你换个浏览器或者换台电脑，新的浏览器里没有服务器对应的 Cookie，就好像是脱掉 了贴着纸条的衣服，健忘的服务器也就认不出来了，只能再走一遍 Set-Cookie 流程。

如果换成 Firefox 等其他浏览器，因为 Cookie 是存在 Chrome 里的，所以服务器就又蒙圈了，不知道你是谁，就会给 Firefox 再贴上小纸条。

### **Cookie的属性**

- Cookie 的有效期可以使用 Expires 和 Max-Age 两个属性来设置。

  **Expires**俗称过期时间，用的是绝对时间点，可以理解为截止日期(deadline)。**Max-Age**用的是相对时间，单位是秒，浏览器用收到报文的时间 点再加上 Max-Age，就可以得到失效的绝对时间。

  Expires 和 Max-Age 可以同时出现，两者的失效时间可以一致，也可以不一致，但浏览器会`优先采用 Max-Age `计算失效期。

- **设置 Cookie 的作用域**，让浏览器仅发送给特定的服务器和 URI，避免被其他网站盗用。

  作用域的设置比较简单，**Domain**和**Path**指定了 Cookie 所属的域名和路径，浏览器在发送 Cookie 前会从 URI 中提取出 host 和 path 部分，对比 Cookie 的属性。如果不满足条件，就不会在请求头里发送 Cookie。

  使用这两个属性可以为不同的域名和路径分别设置各自的 Cookie，比如/19-1用一个 Cookie，/19-2再用另外一个 Cookie，两者互不干扰。不过现实中为了省事，通常 Path 就用一个/或者直接省略，表示域名下的任意路径都允许使用 Cookie，让服务器 自己去挑。

- **Cookie 的安全性**

  在 JS 脚本里可以用 document.cookie 来读写 Cookie 数据，这就带来了安全隐患，有可能会导致跨站脚本(XSS)攻击窃取数据。

  属性**HttpOnly**会告诉浏览器，此 Cookie 只能通过浏览器 HTTP 协议传输，禁止其他方式访问，浏览器的 JS 引擎就会禁用 document.cookie 等一切相关的 API，脚本攻击也 就无从谈起了。

  另一个属性**SameSite**可以防范跨站请求伪造(XSRF)攻击，设置 成SameSite=Strict可以严格限定 Cookie 不能随着跳转链接跨站发送， 而SameSite=Lax则略宽松一点，允许 GET/HEAD 等安全方法，但禁止 POST 跨站发送。

  还有一个属性叫**Secure**，表示这个 Cookie 仅能用 HTTPS 协议加密传输，明文的 HTTP 协议会禁止发送。但 Cookie 本身不是加密的，浏览器里还是以明文的形式存在。

  

### **Cookie的应用**

现在回到我们最开始的话题，有了 Cookie，服务器就有了记忆能力，能够保存状态，那么应该如何使用 Cookie 呢?
 Cookie 最基本的一个用途就是**身份识别**，保存用户的登录信息，实现会话事务。

比如，你用账号和密码登录某电商，登录成功后网站服务器就会发给浏览器一个 Cookie， 内容大概是name=yourid，这样就成功地把身份标签贴在了你身上。

之后你在网站里随便访问哪件商品的页面，浏览器都会自动把身份 Cookie 发给服务器，所 以服务器总会知道你的身份，一方面免去了重复登录的麻烦，另一方面也能够自动记录你的 浏览记录和购物下单(在后台数据库或者也用 Cookie)，实现了状态保持。

Cookie 的另一个常见用途是**广告跟踪**。

你上网的时候肯定看过很多的广告图片，这些图片背后都是广告商网站(例如 Google)， 它会偷偷地给你贴上 Cookie 小纸条，这样你上其他的网站，别的广告就能用 Cookie 读出你的身份，然后做行为分析，再推给你广告。

这种 Cookie 不是由访问的主站存储的，所以又叫第三方 Cookie(third-party cookie)。如果广告商势力很大，广告到处都是，那么就比较恐怖了，无论你走到哪里它都会通过 Cookie 认出你来，实现广告精准打击。

为了防止滥用 Cookie 搜集用户隐私，互联网组织相继提出了 DNT(Do Not Track)和 P3P(Platform for Privacy Preferences Project)，但实际作用不大。



### **小结**

今天学习了 HTTP 里的 Cookie 知识。虽然现在已经出现了多种 Local Web Storage 技术，能够比 Cookie 存储更多的数据，但 Cookie 仍然是最通用、兼容性最强的客户端数据存储手段。

- Cookie 是服务器委托浏览器存储的一些数据，让服务器有了记忆能力
- 响应报文使用 Set-Cookie 字段发送key=value形式的 Cookie 值
- 请求报文里用 Cookie 字段发送多个 Cookie 值
- 为了保护 Cookie，还要给它设置有效期、作用域等属性，常用的有 Max-Age、Expires、Domain、HttpOnly 等
- Cookie 最基本的用途是身份识别，实现有状态的会话事务

注意: 因为 Cookie 并不属于 HTTP 标准(RFC6265，而不是 RFC2616/7230)，所以语法上与其他字段不太一致，使用的分隔符是;，与 Accept 等字段的,不同，小心不要弄错了。

## 参考

[透视HTTP协议(罗剑锋)](https://time.geekbang.org/column/intro/100029001)