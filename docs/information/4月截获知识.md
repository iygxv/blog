---
top: 1
sticky: 1000
sidebar: 
 title: 4月截获知识
 step: 1
 isTimeLine: true
title: 4月截获知识
tags:
 - 知识中心
categories:
 - 知识中心
---


# 4月截获知识

## base64 为什么比 png 大？
一般情况下，base64编码后的字符串长度会比原始图片的大小大约为4/3左右。这是因为base64编码将3个字节转换为4个字符，同时可能会添加一些填充字符。
此外，图片在编码为base64格式时，通常会进行二进制转换，将每个像素的颜色信息转换为二进制数据，然后再将这些二进制数据编码为base64字符串。由于base64编码使用的是文本形式表示二进制数据，因此在编码过程中可能会引入一些额外的开销和填充，从而导致编码后的字符串比原始图片的大小更大。

## 自动生成CHANGELOG
CHANGELOG 会记录所有的 commit 信息并归类版本，可以快速跳转到该条 commit 记录，它能让你方便知道项目里哪个版本做了哪些功能有哪些 bug 等信息。也方便排查 bug，对于提交记录一目了然，不用一个一个去翻去查。
我们使用 standard-version 来实现自动生成 CHANGELOG

```shell
yarn add standard-version -D
```
package.json 增加命令

```json
{
  "scripts": {
    "release": "standard-version"
  }
}

```
当执行以下命令时会自动生成CHANGELOG

```shell
yarn release
```
当然 standard-version 提供自定义配置不同类型对应显示文案，在根目录新建 .versionrc 文件

```json
// .versionrc
{
  "header": "# 更新日志 \n\n",
  "types": [{
      "type": "feat",
      "section": "✨ Features | 新功能",
      "hidden": false
    },
    {
      "type": "fix",
      "section": "🐛 Bug Fixes | Bug 修复",
      "hidden": false
    },
    {
      "type": "init",
      "section": "🎉 Init | 初始化",
      "hidden": true
    },
    {
      "type": "docs",
      "section": "✏️ Documentation | 文档",
      "hidden": false
    },
    {
      "type": "style",
      "section": "💄 Styles | 风格",
      "hidden": true
    },
    {
      "type": "refactor",
      "section": "♻️ Code Refactoring | 代码重构",
      "hidden": true
    },
    {
      "type": "perf",
      "section": "⚡ Performance Improvements | 性能优化",
      "hidden": true
    },
    {
      "type": "test",
      "section": "✅ Tests | 测试",
      "hidden": true
    },
    {
      "type": "revert",
      "section": "⏪ Revert | 回退",
      "hidden": true
    },
    {
      "type": "build",
      "section": "📦‍ Build System | 打包构建",
      "hidden": true
    },
    {
      "type": "chore",
      "section": "🚀 Chore | 构建/工程依赖/工具",
      "hidden": true
    },
    {
      "type": "ci",
      "section": "👷 Continuous Integration | CI 配置",
      "hidden": true
    }
  ]
}

```
## css 文字多行省略
```css
.box {
  width: 100px;
  height: 100px;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  /* 块容器中的内容限制为指定的行数 */
  /* display 属性设置成 -webkit-box 或者 -webkit-inline-box 并且 box-orient 属性设置成 vertical时才有效果。 */
  -webkit-line-clamp: 2;
}
```
## this.$toast这种方式是如何实现的？
**vue2**

- 首先创建一个 toast.vue 组件，然后定义好需要的属性，比如：type、content 等
- 然后使用 vue.extend 创建一个子类构造器，然后通过 new 创建一个实例
- 有了实例之后调用 $mount 方法，将组件挂载到页面上
- 然后可以将 toast 实例元素挂载通过 appendChild 添加到 document.body 上 
- 将上面的过程封装成一个方法，然后将这个方法挂载到原型上

**vue3**

vue3 中，我们可以使用 createApp 创建一个应用实例，通过$mount 方法，将组件挂载到页面上
然后通过 app.config.globalProperties.xxx 添加一个全局属性，然后就可以直接通过 this.xxx 调用了

## 设备像素（dp）、css 像素（css px）、设备像素比（dpr）
### 设备像素（dp）
设备像素（dp）是设备屏幕上显示的物理像素，它与设备屏幕的分辨率是一一对应的。
### css像素（css px）
css 像素是 Web 编程的概念，指的是 CSS 样式代码中使用的逻辑像素
### 设备像素比（dpr）
设备像素比（dpr）是设备屏幕上物理像素与 CSS 像素的比值，它表示设备屏幕的分辨率与 CSS 样式代码中设置的分辨率的比值。

在浏览器上 iPhone6/7/8 375px ，通过 window.devicePixelRatio 可以获取到  iPhone6/7/8 设备像素比为 2
所以一般开发都是使用二倍图来开发


## 异常捕获

```js
try{
 	 // 可能出错的代码
}catch(e){
 	 // 处理try代码块中抛出的异常
 	 // e 错误信息
 	 throw // 抛出自定义异常
}finally{
 	 // 无论什么情况都会执行代码块
}
```

## 判断可迭代对象

```js
typeof obj[Symbol.iterator] === 'function'
// 如果为true, 则是可迭代对象
// 如果为false, 则不是可迭代对象
```

## Symbol 的元编程能力(改写语法本身)
```js
let obj = {
  a: '1',
  [Symbol.toStringTag]: 'vity'
}
console.log(Object.prototype.toString.call(obj)) // [object vity]
```

## 0.1 + 0.2 != 0.3 问题
0.1 + 0.2 != 0.3 的原因：
我们小数在转换成二进制的时候，结果是无限循环的，但是我们计算机存储的时候，存储的位数是有限，那么就必须做一些近似值的取舍，这样就导致了小数精度丢失了

`解决方法:` 先将小数乘以10的n次方倍，装换为整数，再将计算后的结果除以10的n次方倍

```js
let a = 0.1
let b = 0.2
(a * 10 + b * 10) / 10 === 0.3 // true

```
## String.prototype.replace()
replace第二个参数是一个函数的问题
```js
function render(template, data) {
  // \为转义
  let str = template.replace(/\{\{(\w+)\}\}/g, (match, key) => {
    console.log(match)
    console.log(key)
    /*
     *match =>{{name}} 字符串中匹配到的子串
     *key =>name  代表括号匹配的字符串 （重点：括号 -> \w+）
     */
    return data[key]
  })
  return str
}

let template = '我是{{name}}，年龄{{age}}，性别{{sex}}'
let data = {
  name: '小明',
  age: 18
}

render(template, data) // 我是小明，年龄18，性别undefined
```
这里可以知道
- match会匹配到字符串的子串
- key会匹配括号里的内容

## es5实现const
```js
Object.defineProperty(window, 'name', {
    value: 'vvv',
    writable: false // 控制可写属性
})
// 这样子相当于 const name = 'vvv'
window.name = '123'
window.name // 'vvv' 
```

## 有 1000 个 dom，需要更新其中的 100 个，如何操作才能减少 dom 的操作？
添加多个dom元素，可以把元素先append进DocumentFragment中去，最后再统一将DocumentFragment添加到页面中(`文档碎片流`)

`提醒: 不会进行多次重排和重绘, 只进行一次`
```js
const ul = document.createElement('ul')
const fragment = document.createDocumentFragment()
for (let i = 0; i < 100; i++) {
  const li = document.createElement('li')
  li.innerHTML = `index: ${i}`
  // 正序插入
  // fragment.appendChild(li)
  // 倒序插入
  fragment.insertBefore(li, fragment.childNodes[0])
}
ul.appendChild(fragment)
```

## webpack中的source map是什么,生产环境怎么用?

source map 构建了处理前的代码和处理后的代码之间的桥梁,在打包之后也可以看到打包之前的代码,可以快速定位 bug




<br/>
<hr />

⭐️⭐️⭐️好啦！！！本文章到这里就结束啦。⭐️⭐️⭐️

✿✿ヽ(°▽°)ノ✿

撒花 🌸🌸🌸🌸🌸🌸

